## 设计说明

首先，我们定义权限的概念是两个：

- 某个用户是否拥有访问某个接口的权限
- 某个用户是否拥有访问某个数据的权限

就是我们常说的接口权限和数据权限，二者在权限管理中是两个不同的概念，相互边界非常清楚，

所以我们在设计权限管理模块的时候，也是分为两个模块来设计的。

### 1.接口权限设计

首先对于接口权限，以第一性原则来考虑这个事情，设计的初衷是判断用户是否具有对某个接口的访问权限，
所以最直接的做法是我们在数据库中设计一张表，里面存储了所有用户对所有接口的访问权限配置：
如：

| 用户id | 接口地址     | 是否有权限 |
|------|----------|-------|
| 1    | /xxx/xxx | true  |
| 1    | /xxx/aaa | true  |
| 2    | /xxx/xxx | true  |
| 2    | /xxx/aaa | true  |

这样设计可以绝对的满足我们的原始需求，每一个请求过来的时候，我们都去数据库中查询对应的用户是否拥有对这个接口的访问权限，但是这样的设计会有以下问题：

1. 权限配置与代码耦合，每次新增一个接口，都需要在数据库中配置一次，而且很多权限是重复的，比如修改用户的电话号码与修改用户的地址，这两个接口的权限是一样的，但是我们需要在数据库中配置两次
2. 重复工作太多，比如新创建了一个用户，那么就需要对所有接口进行配置
3. 对于主流的后端框架要求根据用户可以权限化的控制对应的菜单与按钮，这样的设计无法满足这个需求

首先，对于第一个问题，我们引入权限字符与权限模块的概念，

权限字符表示权限最小的细分单位，比如：添加用户，修改用户等等，设计权限字符是全局唯一的，不会重复，

而权限模块是对权限字符的一个归总，比如：用户管理模块，角色管理模块等等，每一个权限模块下面都有很多权限字符，

对于任意一个需要进行权限过滤的接口来说，我们都会对他进行标记一个或者多个权限字符，表示这个接口的内部逻辑需要这些权限字符才能访问，

所以我们现在的用户权限表就变成了这样：

**用户权限表：**

| 用户id | 权限字符        |
|------|-------------|
| 1    | add_user    |
| 1    | update_user |
| 2    | add_user    |
| 2    | update_user |

依托于一些预设的自动化策略，我们可以在程序运行期间，动态的更新生成一张完整的权限模块字典表，用于管理用户权限配置的参照，与代码进行解耦。

**权限模块字典表：**

| 权限字符        | 权限模块         |
|-------------|--------------|
| add_user    | user_manager |
| update_user | user_manager |

接下来是第二个问题，如何高效的管理用户的权限配置，我们引入了角色的概念，角色是权限的集合，我们可以将一些常用的权限配置成一个角色，然后将这个角色赋予用户，这样就可以减少用户权限配置的工作量，如：

**角色表：**

| 角色id | 角色名称  |
|------|-------|
| 1    | admin |

**用户角色关联表：**

| 用户id | 角色id |
|------|------|
| 1    | 1    |
| 2    | 1    |

**角色权限关联表：**

| 角色id | 权限字符        |
|------|-------------|
| 1    | add_user    |
| 1    | update_user |

至此，如果不考虑前端的菜单按钮权限控制，我们的权限管理模块就设计完成了，每拦截一个请求的时候，我们会根据当前用户获取到他对应角色的权限字符，然后根据这些权限字符去匹配当前请求的接口是否需要这些权限字符，如果需要则放行，否则拦截。

然后配合用户的角色配置功能，角色的权限字符配置功能，我们可以很方便的管理用户的权限配置。

但是，第三个问题是我们在后台管理系统中无法去回避的问题，系统需要满足菜单权限控制与菜单内的功能权限控制，这个问题我们引入了资源的概念。

我们将菜单与菜单内的功能都定义为资源，资源是权限字符的集合，然后再将资源分配给角色，这样我们就可以实现所需要的功能了。

**菜单表：**

| 菜单id | 菜单名称 | 菜单编码        |
|------|------|-------------|
| 1    | 用户管理 | userManager |

**功能表：**

| 功能id | 功能名称 | 功能编码    | 菜单id |
|------|------|---------|------|
| 1    | 添加用户 | addUser | 1    |

**资源权限表**

| 资源id | 资源类型 | 权限字符        |
|------|------|-------------|
| 1    | 菜单   | add_user    |
| 1    | 功能   | update_user |

**角色资源关联表**

| 角色id | 资源id | 资源类型 |
|------|------|------|
| 1    | 1    | 菜单   |
| 1    | 1    | 功能   |

至此，我们的权限管理模块就设计完成了，满足我们既定的一些需求，整体的表结构设计如下：

**1.权限字符字典表: sys_auth_code**

字典表，数据不可见，不可编辑，系统自动维护

| 字段名称        | 字段类型        | 字段说明                      |
|-------------|-------------|---------------------------|
| auth_code   | varchar(50) | 权限字符，全局唯一                 |
| auth_module | varchar(50) | 权限模块，数据标注类型的字段，不影响权限校验流程  |
| auth_title  | varchar(50) | 权限字符的简单语义化描述，如:创建用户，创建角色等 | 

**2.菜单表: sys_menu**

菜单字典表，可见，可编辑部分字段，如图标，排序，菜单状态等，系统自动生成

| 字段名称        | 字段类型        | 字段说明                                  |
|-------------|-------------|---------------------------------------|
| id          | varchar(32) | 菜单id，物理主键，uuid                        |
| menu_title  | varchar(50) | 菜单名称                                  |
| menu_code   | varchar(50) | 菜单编码，不可见，不可编辑，主要用于一些对应场景，如前端依照与此对应路由等 |
| menu_type   | int(2)      | 菜单类型，目录或者菜单，目录表示只是一个容器，菜单表示可以点击的菜单    |
| parent_id   | varchar(32) | 父级菜单id，如果是根节点则为null                   |
| menu_order  | float       | 菜单排序，用于前端菜单的展示排序                      |
| menu_status | int(1)      | 菜单状态，表示菜单是否被禁用                        |
| menu_icon   | varchar(50) | 菜单图标，扩展字段                             |

**3.功能表: sys_menu_fc**

功能字典表，可见，可编辑部分字段，如功能状态,禁用等，系统自动生成

| 字段名称      | 字段类型        | 字段说明                                  |
|-----------|-------------|---------------------------------------|
| id        | varchar(32) | 功能id，物理主键，uuid                        |
| fc_title  | varchar(50) | 功能名称                                  |
| fc_code   | varchar(50) | 功能编码，不可见，不可编辑，主要用于一些对应场景，如前端依照与此对应UI等 |
| menu_id   | varchar(32) | 父级菜单id，如果是根节点则为null                   |
| fc_status | int(1)      | 功能状态，表示菜单是否被禁用                        |

**4.资源权限字符字典表: sys_resource_code**

资源权限字典表，数据不可见，不可编辑，系统自动维护

| 字段名称          | 字段类型        | 字段说明          |
|---------------|-------------|---------------|
| id            | varchar(32) | id，物理主键，uuid  |
| resource_id   | varchar(32) | 资源id    ，索引字段 |
| resource_type | int(2)      | 资源类型，菜单或者功能   |
| auth_code     | varchar(50) | 权限字符，全局唯一     |

**5.角色表: sys_role**

角色表，可见，可编辑，管理员角色不可编辑，不可删除，且保证系统中最少存在一个管理员角色，管理员角色不受权限约束，可见所有菜单与功能

| 字段名称        | 字段类型         | 字段说明           |
|-------------|--------------|----------------|
| id          | varchar(32)  | 角色id，物理主键，uuid |
| role_name   | varchar(50)  | 角色名称           |
| role_status | int(1)       | 角色状态，表示角色是否被禁用 |
| is_admin    | int(1)       | 是否是超级管理员       |
| role_remark | varchar(200) | 角色备注           |

**6.用户角色关联表: sys_user_role**

用户角色关联表，可见，可编辑，用户角色关联表，一个用户可以拥有多个角色，一个角色可以被多个用户拥有，最少存在一个管理员角色

| 字段名称    | 字段类型        | 字段说明         |
|---------|-------------|--------------|
| id      | varchar(32) | id，物理主键，uuid |
| user_id | varchar(32) | 用户id ，索引字段   |
| role_id | varchar(32) | 角色id ，索引字段   |

**7.角色资源关联表: sys_role_auth**

角色权限关联表，可见，可编辑，存储角色对菜单与功能的权限配置

| 字段名称          | 字段类型        | 字段说明         |
|---------------|-------------|--------------|
| id            | varchar(32) | id，物理主键，uuid |
| role_id       | varchar(32) | 角色id ，索引字段   |
| resource_id   | varchar(32) | 资源id ，索引字段   |
| resource_type | int(2)      | 资源类型，菜单或者功能  |

**8.用户表: sys_user_auth**

用户表不提供详细的字段，但是提供基础字段，由业务系统自行扩展维护，并且框架会自动生成一个超级管理员用户

| 字段名称        | 字段类型         | 字段说明           |
|-------------|--------------|----------------|
| id          | varchar(32)  | 用户id，物理主键，uuid |
| user_name   | varchar(50)  | 用户账号，索引字段      |
| pass_word   | varchar(50)  | 密码             |
| nick_name   | varchar(50)  | 用户昵称           |
| user_status | int(1)       | 用户状态，表示用户是否被禁用 |
| seq_number  | int(5)       | 用户序列号，修改密码之后更新 |

### 2.数据权限设计

数据权限设计是一个比较复杂的问题，因为数据权限的规则需要根据业务场景来定制.

我们的想法是，数据权限设计的最原始的目的是为了保证用户只能看到或者编辑自己有权限的数据，那么总结起来无非就是以下两个问题：

1. 如何使系统只能查询到用户有权限的数据
2. 如何判断对应的数据，用户是否有权限

对于第一个问题，想像一下，当我们查询数据的时候，原始的流程，是给予或者不给予一个或者多个条件，然后程序根据条件去数据库中检索数据，但是在数据权限的设计下，我们需要在这些条件的外面再添加一个约束范围，

比如我们想要去数据库中查询名字叫做张三丰的人，那么在数据权限需求的设计中，我们可以将这个条件改为，查询名字叫做张三丰的人，并且他的创建者是当前用户，

又比如我们需要检索公司的员工信息，那么我们可以将这个条件改为，查询公司的员工信息，并且他的部门是当前用户所在的部门，

所以我们的数据权限设计的核心就是在查询条件的外面再添加一个约束范围，这个约束范围是根据当前用户的权限来决定的。

而对于第二个问题，其实很简单，只要我们当前既定的数据进行权限判断既可，比如我要编辑一个用户的信息，那么我只需要判断这个用户的创建者是否是当前用户即可。

综上所述，约束赋予的本质是添加不受请求控制的额外参数，而权限检查的本质是对请求的参数进行校验，

最后，不论是约束赋予，还是数据权限判断，我们应该定义在框架的某一个代码级别进行统一处理，因为我们本身期望的就是一个统一的权限管理框架，

常规或者经典的java后端架构中，大部分情况下都至少不会脱离以下三层：

- controller层
- service层
- dao层

当然也有一些特殊的架构，删除了service层，以满足最极简快速的开发需求，

我们从下往上考虑，

1. dao层是最底层的数据访问层，通常一条请求的执行链中，可能会含有多个dao层的操作，那么权限判断会执行多次，并且约束赋予，对于上层调用者来说是个不透明的中间行为，不利于理解与维护
2. service层是业务逻辑的处理层，与dao层一样，同样存在对应的问题
3. controller层是请求的入口，用户与系统的交互的最外一层，约束赋予与权限检查都可以完成、

所以我们的设计是，将数据权限的约束赋予与权限检查放在controller层

